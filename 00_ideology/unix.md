UNIX哲学

https://zh.wikipedia.org/wiki/Unix%E5%93%B2%E5%AD%A6#/

程序应该只关注一个目标，并尽可能把它做好。让程序能够互相协同工作。应该让程序处理文本数据流，因为这是一个通用的接口。

1. 你永远不会知道你的程序会在什么地方耗费时间。程序的瓶颈常常出现在意想不到的地方，因此在你确信找到瓶颈后再动手优化代码吧。
2. 测试代码。只有在你详细测试了代码，并且发现一部分代码耗费了绝大部分的运行时间时再对程序作速度优化。
3. 功能全面的算法（fancy algorithm）在处理小规模问题时效率很低，这是因为算法时间效率中的常量很大，而问题往往规模很小。除非你知道你遇到的常常是复杂的情况，否则就让代码丑陋但是简单而高效吧。（即使问题规模确实很大，也首先尝试第二条规则。）
4. 功能全面的算法比简单的算法更容易产生bug，更难实现。尽量使用简单的算法和数据结构。
5. 数据决定一切。如果选择的数据结构能很好的管理数据，算法部分往往不言自明。记住，数据结构，而非算法，才是编程的关键。
6. 没有第六条规则。


格言

1. 小即是美。
2. 让程序只做好一件事。
3. 尽可能早地建立原型。
4. 可移植性比效率更重要。
5. 数据应该保存为文本文件。
6. 尽可能地榨取软件的全部价值。
7. 使用shell脚本来提高效率和可移植性。
8. ~~避免使用可定制性低下的用户界面。~~
9. 所有程序都是数据的过滤器。

